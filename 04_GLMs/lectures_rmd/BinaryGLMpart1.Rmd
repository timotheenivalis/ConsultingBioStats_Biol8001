---
title: "Generalized Linear Models"
subtitle: "Introduction and binary data"
author: "Timothee Bonnet"
date: "3 September 2021"
output: 
  html_document:
    theme: united
    highlight: pygments
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Goals for today:

* Understand why linear models do not work well with some types of data (e.g., binary data)
* Fit generalized linear models (GLMs), in particular binary binomial (a.k.a., logistic regression)
* Visualize binomial GLMs


Why start with binary GLMs? Because these are the simplest of all GLMs. Not too much can go wrong with them. In future sessions we will work with other types of GLMs for which we will need to learn some more concepts and be more careful with assumptions.

Today we will need the following packages:
```{r, message=FALSE}
library(tidyverse) #including ggplot2
library(ggbeeswarm)
library(ggResidpanel)

library(glmmTMB)
library(DHARMa)
library(emmeans)
```

In addition, if you want to draw the diagrams representing our models, you can install:
```{r}
library(DiagrammeR)
```


# Failure of linear models

## What a simple linear model is supposed to do

We can draw a simple linear model like:

```{r}
grViz("
digraph boxes_and_circles {
node [shape = square, color = DeepSkyBlue]
response; predictor

node [shape = diamond, color=ForestGreen]
intercept; effect

node [shape = circle, color = black]
'expected value';

'expected value' -> response [ label = '  + rnorm(0,\U03C3)', style=dashed, fontcolor=ForestGreen]; 
intercept -> 'expected value';
predictor -> effect  [arrowhead = none, label = ' \U00D7']; 
effect -> 'expected value' ;
}")
```

```{r}
grViz("
digraph boxes_and_circles {
node [shape = square, color = DeepSkyBlue]
response; predictor

node [shape = diamond, color=ForestGreen]
'rnorm() noise'; effect

node [shape = circle, color = black]
'expected value';

'expected value' -> response; 

predictor -> effect  [arrowhead = none, label = ' \U00D7']; 
effect -> 'expected value' ;
'rnorm() noise' -> response
}")
```

Or if you prefer, we can write an equation:

$$
response = intercept + effect \times predictor + residual \text{, with }  residuals \sim Normal(0, \sigma)
$$
First, let us look at an example when a linear model performs fine.
We simulate data following all the assumptions of a linear model with equation

First, we choose parameter values for the equation:
```{r}
number_of_observations <- 30
intercept <- 1
effect <- 0.5
sigma_residual <- 1
```

Then we draw random numbers for the predictor (for which we don't have an equation, so we could do whatever) and for the response  according to the equation:
```{r}
set.seed(934)
# 
# predictor <- rnorm(n = number_of_observations, mean = 0, sd = 1)
# 
# response <- intercept + effect*predictor + rnorm(n = number_of_observations,mean = 0, sd = sigma_residual)

data_linear <- tibble(predictor = rnorm(n = number_of_observations, mean = 0, sd = 1),
                      response = intercept + effect*predictor + rnorm(n = number_of_observations,mean = 0, sd = sigma_residual))
```

Let us visualize these data
```{r}
(p <- ggplot(data_linear, aes(x=predictor, y=response))+
  geom_point())
```

We fit a simple linear model and visualise the model prediction:
```{r}
lm0 <- lm(response~predictor, data = data_linear)
summary(lm0)

(p <- p + geom_smooth(method="lm"))
```

Next we draw the residuals:
```{r}
p + geom_segment(aes(x=predictor, y=response, xend= predictor, yend=lm0$fitted.values))
```

Residuals look mostly unstructured, random and normally distributed. We can better assess these properties using diagnostic plots showing different properties of the residuals:

```{r}
resid_panel(lm0)
```

Diagnostic plots may not look very good, but there is actually no serious violation of assumptions.
That looks like an acceptable linear model.


### When a linear model fails

Now let's generate data with the same structure, except we convert the continuous values to binary values, following a logistic transformation and a Bernoulli distribution. For this type of data we generally want to model the probability of a 1 (survival, presence, success...). Data can be either 0 or 1. Although we cannot observe values between 0 and 1 (e.g., 0.5) in the data, we can interpret such a value: it is a probability (of observing a 1). On the other hand, values below 0 or above 1 are meaningless for a binary variable.

```{r}
grViz("
digraph boxes_and_circles {
node [shape = square, color = DeepSkyBlue]
response; predictor

node [shape = diamond, color=ForestGreen]
intercept; effect

node [shape = circle, color = black]
'expected value';

'expected value' -> probability [ label = '  inverse logit']; 
probability -> response [ label = '  rbinom(size=1, p=probability)', style=dashed]; 
intercept -> 'expected value';
predictor -> effect  [arrowhead = none, label = ' \U00D7']; 
effect -> 'expected value' ;
}")
```

Or if you prefer, we can write an equation:

$$
response \sim \mathrm{Bernoulli} (\mathrm{logit}^{-1} (intercept + effect \times predictor) )
$$

```{r}
set.seed(935)
number_observations <- 30
intercept <- 1
effect <- 2

predictor <- rnorm(n = number_observations,mean = 0,sd = 1)

latent <- intercept + effect*predictor
probability <- plogis(latent)
response <- sapply(probability, FUN=function(x){rbinom(1,1,x)})

data_binary <- tibble(predictor=predictor, response=response)

ggplot(data_binary, aes(x=predictor, y=response))+ geom_beeswarm(groupOnX = FALSE)
```

Let's fit a linear regression to these data and visualise the result.
```{r}
lm1 <- lm(response~predictor, data = data_binary)
summary(lm1)

ggplot(data_binary, aes(x=predictor, y=response))+
geom_smooth(method="lm", fullrange=TRUE) + geom_point(alpha=0.5) +
geom_segment(aes(x=predictor, y=response, xend=predictor, yend=lm1$fitted.values), alpha=0.4) +
  xlim(c(-3,1.2))
```

Several problems are apparent:

* The regression line (in blue) goes below 0 and above 1.
* The uncertainty (confidence interval in grey) gets larger for extreme values of the predictor, whereas it seems like we are pretty sure there will be only 0s below $x=-2$ and only 1s above $x=1$, the uncertainty should be smaller on the sides!
* Residuals are not independent of each other (they are more or less ranked from left to right) and their variation is not constant (from left to right the variation is small, then big, then small).

In addition, if we look at the diagnostic plots:
```{r}
resid_panel(lm1)
```

* We see bands in the first plot: residuals are not independent of each other.
* The QQplot and the histogram show signs of non-normality (although that is not a big problem! Linear models are pretty robust to non-normality)

*That is not a good linear model. Inference from such a model is unreliable. In particular you should not trust any measure of uncertainty (Standard Error, Confidence Interval, p-value), and you should certainly not trust extrapolation.*

## The solution: fit GLM for binary data, the binomial family

Instead of a linear model, here we need to use a **Generalized Linear Model** (GLM). GLMs come in different flavours or *families*, each adapted to different types of response variables. Here we will talk about GLMs for binary data, which belong to the *binomial family*.

Before discussing what a GLM is in details, let's see that it is very easy to fit one in R. We can use the function `glm()`, which works exactly like `lm()`, except that you need to specify a family:

```{r}
glm1 <- glm(response~predictor, data = data_binary, family = "binomial")
summary(glm1)
```

The `summary` output looks very similar to that of `lm()`. From a quick look we see that the predictor has a positive effect on the response, as expected.

ANOVAs are difficult with GLMs, but we can still have a look to confirm that there is good evidence that the predictor has an effect on the response. We just need to specify `test=Chisq`.
```{r}
anova(glm1, test = "Chisq")
```


Let's see what the model prediction looks like:
```{r}
(p <- ggplot(data_binary, aes(x=predictor, y=response))+ 
  geom_smooth(method="glm", method.args = list(family="binomial"), fullrange=TRUE) +
  geom_point())
```

That looks good!

What happens to the prediction when we extrapolate beyond the range of $x$ values?
```{r}
p + xlim(-10,10)
```

Two very good points:

1. The prediction line never goes below 0 or above 1
2. The uncertainty shrinks as we get to more extreme values of $x$

Two of the three problems we saw with `lm()` are fixed. What about the third one, the distribution of residuals?



## Checking GLM assumptions

```{r}
p + geom_segment(aes(x=predictor, y=response, xend=predictor, yend=fitted(glm1)))
```

```{r}
resid_panel(glm1)
```

The residuals do not look much better with the `glm()` than with the `lm()`. **But that is okay!** GLMs do not have the same assumptions as LMs. In fact, for binary binomial GLMs there are very few assumptions. The only one you need to remember for now is that observations are assumed to be independent of each other conditional on predictors, or in different words, your model should not leave important blocking factors unaccounted for. 

**When working with GLMs, the function `resid_panel()` is useless.**

What to do then? The basic idea is to simulate fake data from the model we fitted and compare them to real data. If the model is a good fit to the data, then the simulated data should look like the real data.

For instance, let's visualise the mean and standard deviation of simulated versus real data
```{r}
real_properties <- data_binary %>% 
  summarise(mean=mean(response), sd=sd(response)) %>%
  pivot_longer(cols = c(mean, sd), names_to = "property")

simulated_properties_glm <- map_dfr(.x = 1:1000, ~{simulate(glm1)}, .id = "simulation" ) %>%
  group_by(simulation) %>%
  summarise(mean=mean(sim_1), sd=sd(sim_1)) %>%
  pivot_longer(cols = c(mean, sd), names_to = "property")


  
simulated_properties_glm %>% ggplot(aes(y=value, x=property)) +
  geom_violin() + 
  geom_point(data=real_properties, col="red")
```


It looks like our model generates the most likely values of both mean and variance. That is good, but that is only 2 properties out of 30 data points, and we needed quite a lot of complex code to get there!

In addition, the linear model seems to perfect very well too:
```{r}
simulated_properties_linearmodel <- map_dfr(.x = 1:1000, ~{simulate(lm1)}, .id = "simulation" ) %>%
  group_by(simulation) %>%
  summarise(mean=mean(sim_1), sd=sd(sim_1)) %>%
  pivot_longer(cols = c(mean, sd), names_to = "property")

simulated_properties_linearmodel %>% ggplot(aes(y=value, x=property)) +
  geom_violin() + 
  geom_point(data=real_properties, col="red")
```


Fortunately, there is package that automates and make the assessment mathematically more correct and powerful, by focusing on various aspects of the distribution of real and simulated residuals (transformed with some clever math), so that we can assess all aspects of the model fit (not just the mean and variance).

```{r}
library(DHARMa)
```

We will generally use this package in two ways:

1. Test whether the data generated have the same distribution as the real data (first plot), and whether the transformed residuals appear randomly distributed across the data generated by the model (second plot):

```{r}
plot( simulateResiduals(glm1) )
```

2. Test whether the model generates the right amount of variation (here we compare the standard deviation of transformed residuals, between real and simulated data):
```{r}
testDispersion(glm1)
```


Let's see if the linear model performs well (NB: we already know lm1 is not great because of the output of `resid_panel() `):

```{r}
plot( simulateResiduals(lm1) ) # pretty bad distribution of residuals
testDispersion(lm1) #no problem here
```


Here the linear model is clearly not a good fit. A note of warning though: do not trust those tests and plots blindly! If you have good conceptual reasons to think a linear model is wrong for a dataset, don't let non-significant p-values change your mind.


We will practice more how to use DHARMa in future sessions. For now know that it is a good option to test GLMs assumptions.


# Start second session here!

Reminder: we simulated those data, using a generative model corresponding to a binomial GLM:
```{r}
set.seed(935)
number_observations <- 30
intercept <- 1
effect <- 2

predictor <- rnorm(n = number_observations,mean = 0,sd = 1)

latent <- intercept + effect*predictor
probability <- plogis(latent)
response <- sapply(probability, FUN=function(x){rbinom(1,1,x)})

data_binary <- tibble(predictor=predictor, response=response)
ggplot(data_binary, aes(x=predictor, y=response))+ geom_beeswarm(groupOnX = FALSE)
```

A linear model (in red) shows many pathologies, whereas a binomial GLM does what we want:
```{r}
ggplot(data_binary, aes(x=predictor, y=response))+ geom_beeswarm(groupOnX = FALSE) +
  geom_smooth(method="lm", col="red", fill="red", fullrange=TRUE) + 
  geom_smooth(method="glm", col="blue", fill= "blue", method.args = list(family="binomial"), fullrange=TRUE)  +
  xlim(c(-4, 4))
```


## Practice with snow voles survival, understanding link functions and interpreting parameter estimates


The data set "voles_early.csv" contains records from the beginning of the survey of a wild rodent population. Among the variables is "survival", a binary variable indicating whether an individual captured on a given year survived to the next year. We want to understand variation in survival and in particular whether there is natural selection on body mass through survival. Other variables than body mass probably structure the variation in survival, making less clear what model we should use. Therefore we start building our models trying to see if sex, age and other variables matter for survival.

![cute snow vole](cutevole.jpg)


```{r}
survdat_early <- read_csv("Data/voles_early.csv")

summary(survdat_early)

survdat_early %>% group_by(sex) %>%
  summarize(p_survival=mean(survival), count_survival=sum(survival), count_death=sum(1-survival))

vole_s_glm <- glm(survival ~ sex, data = survdat_early, family = "binomial")
summary(vole_s_glm)

```


How to interpret the summary output? What are these parameters and how do they relate  to the probability of year-to-year survival in females and males?

```{r}
coef(vole_s_glm)

survdat_early %>% group_by(sex ) %>% summarize(mean=mean(survival)) 
```

Parameter estimates actually predict mean sex-specific survival, but it is not obvious because the GLM is fitted, not on the scale of probabilities, but on a transformed linear scale (on which effects are linear, like in a linear model).

All GLMs have such a transformation. It is called the "*Link function*".

To go from a probability to the linear scale our GLM applied a logit link function:

$$
\mathrm{logit}(p) = \log(\frac{p}{1-p})
$$

To go from model predictions on the linear scale to the probability scale we apply the inverse link function, which is
$$
\mathrm{logit}^{-1}(y) = \frac{1}{1+e^{-y}}
$$
in R you can run this inverse logit function with `plogis()`.

So, our model told us that the predicted survival for females (the intercept) was:
```{r}
1/(1+exp(-coef(vole_s_glm)[1]))
plogis(coef(vole_s_glm)[1])
```

And the predicted survival for males was:
```{r}
plogis(coef(vole_s_glm)[1] + coef(vole_s_glm)[2] )

```

In a binomial GLM, when you want to calculate something on the probability scale (that makes more sense to the human brain) from parameter estimates you:

1. Calculate the prediction using parameter estimates on the linear scale
2. Apply the inverse transformation used in the GLM. 

It does not work if you apply the inverse transformation on different parameters separately. 


#### Using `emmeans()`

It is a good idea to know how to back-transform link functions by hand: it forces you to understand how GLMs work, it is useful to simulate data and sometimes you really need to do calculations by hand. However, most of the time functions like `emmeans()`  are a useful shortcut. You need to be control the argument `type = ` (what scale do you want the prediction on? "link" means the scale of the linear model; "response" means scale of probability).

```{r}
emmeans(vole_s_glm, ~sex, type="response")
```

## What about data generation?

So, a GLM predicts probabilities, values between 0 and 1. But we observe only 0s and 1s. Does the GLM knows about that? Yes it does! The GLM relates probabilities to data in a very obvious way: for a predicted probability $p$, the GLM thinks you should observe a proportion $p$ of 1s and a proportion $1-p$ of 0s.
If it seems trivial, it is because it is. GLMs for binary data are really easy.

Other GLMs use more complex processes, so let us look more formally at how a binary GLM sees the world.

The distribution turning a probability $p$ into 0s and 1s is the bernoulli distribution, a special case of the binomial distribution. We can draw random samples from the bernoulli distribution with `rbinom(n=, size=1, prob=)`

```{r}
(bernoulli_sample <- rbinom(n = 1000, size = 1, prob = 0.3))

mean(bernoulli_sample)
```

All GLMs use distributions that have some kind of relationship between their mean and their variance. For the bernoulli, the relationship is $variance = mean*(1-mean)$, and the mean is expected to be equal to the probability.


```{r}
var(bernoulli_sample)

mean(bernoulli_sample)*(1-mean(bernoulli_sample))
```

That means that binary data are most variable for a probability of 0.5, and least variable for probabilities close to 0 or close to 1.

```{r}
nb_rows <- 1000
variability_bernoulli <- tibble(lm_value= seq(-5,5, length.out = nb_rows),
       probability = plogis(lm_value),
       observation = rbinom(n = nb_rows, size = 1, prob = probability))

ggplot(variability_bernoulli, aes(x=lm_value, y=probability, col=probability)) +
  geom_line()+
  geom_point(inherit.aes = FALSE, aes(x=lm_value, y=observation))
```

Let's simulate survival for each sex based on the predicted survival probabilities:
```{r}
pred_survival <- summary(emmeans(vole_s_glm, ~sex, type = "response"))

simulated_survival <- pred_survival %>%  
  group_by(sex) %>%
  select(prob) %>%
  summarise(survival = rbinom(n = 100, size = 1, prob = prob), prob=prob)


simulated_survival %>% group_by(sex) %>%
  summarise(simulated_mean = mean(survival), expected_mean=mean(prob),
            simulated_var = var(survival), expected_var=mean(prob)*(1-mean(prob)))

```


## What a GLM is

From previous examples we saw what a GLM is:

1. A linear model (response = intercept + slope × predictor . . . ), what you see with summary(glm1)
2. A "Link function" = a map between the linear function (−∞ to +∞) and a
probability distribution (from 0 to 1 for bernoulli)
3. A probability distribution (bernoulli, Binomial, Poisson. . . ) assumed to generate
the data (either 0 or 1 for bernoulli)

![glm scales](scales.png)


$$
y_i = \alpha + \beta x_i \\
p_i = \mathrm{logit}^{-1}(y_i) \\
\mathrm{obs}_i \sim Bernoulli(p_i)
$$



## More practice with snow voles

Let's consider the relationship between mass and survival.

```{r}

ggplot(survdat_early, aes(x = mass, y=survival)) +
  geom_point(alpha=0.2)
```

Difficult to see much on this plot. Better to add some jitter/beeswarm and a glm fit:


```{r}
ggplot(survdat_early, aes(x = mass, y=survival)) +
  geom_beeswarm(groupOnX = FALSE) +
  geom_smooth(method = "glm", method.args=list(family="binomial"))

```

```{r}
vole_glm <- glm(survival ~ mass, data = survdat_early)
summary(vole_glm)
```

So it looks like higher body mass corresponds to lower survival across the population.

